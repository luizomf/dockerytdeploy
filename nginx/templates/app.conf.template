# This is meant to be the final Nginx configuration file

# Tells Nginx the DNS used to resolve names. Since we're using docker,
# the 127.0.0.11 is the Docker DNS. When we change something in a container
# and its IP changes, Nginx will know it almost immediately.
# "valid=1s" the frequency when Nginx resolver resolves DNS names
# "ipv6=off" turns IPv6 off. If you use IPv6, feel free to change it to `on`.
resolver 127.0.0.11 valid=1s ipv6=off;

upstream backend {
  # Shared memory zone for the state of our workers.
  zone upstream_backend 128k;

  # DC_APP_CONTAINER_NAME needs to be set in the .env file.
  # This defines the upstream server using the Docker container name. Since we are
  # scaling our containers, this should resolve automatically to the IPs of all
  # available replicas. If there are more then one server, Nginx will became a
  # load balancer using the round robin algorithm.
  server ${DC_APP_CONTAINER_NAME}:8000 resolve;

  # keepalive tells Nginx to reuse TCP connections to upstream servers instead
  # of opening a new one per request.
  # Each Nginx worker process can keep up to 32 idle connections
  # It improves overhead, but may hang some connections.
  keepalive 32;
}

# This server block is for certbot challenges. When you are renewing your certificates
# this will be used.
server {
  # HTTP only (port 80)
  listen 80;
  listen [::]:80;

  # Domains come from .env file
  server_name ${DOMAINS};

  # Removes Nginx version from the response (less information)
  server_tokens off;

  # This is the endpoint used by Certbot (webroot) for HTTP-01 validation.
  # If you look at our volumes, we mounted ./ssl_conf/certbot/www:/var/www/certbot.
  # This volume is shared between Nginx and Certbot containers.
  location /.well-known/acme-challenge/ {
    root /var/www/certbot;
  }

  location / {
    # The HTTP 301 status code means "Moved Permanently". We are not answering
    # any other request using HTTP, instead, we are redirecting to HTTPS.
    return 301 https://$host$request_uri;
  }
}

# SERVER HTTPS (443) -> The Reverse Proxy
# This block will receive requests and pass it to our app.
server {
  # HTTPS only (port 443)
  listen 443 ssl;
  listen [::]:443 ssl;

  # Set the domains in the .env file
  server_name ${DOMAINS};

  # Remove Nginx version from the response for security reasons
  server_tokens off;

  # Ths current env variable need to be set in the .env file.
  # When in development mode, we'll use self signed certificates.
  # When in production, we'll use the certificates from certbot / Let's Encrypt.
  ssl_certificate /etc/letsencrypt/live/${CURRENT_ENV}/fullchain.pem;
  ssl_certificate_key /etc/letsencrypt/live/${CURRENT_ENV}/privkey.pem;

  # This configurations will be downloaded directly from certbot's github.
  # This is done automatically by the `bootstrap.sh` script.
  include /etc/letsencrypt/conf/options-ssl-nginx.conf;
  # Diffie-Hellman parameters file. The same as above.
  ssl_dhparam /etc/letsencrypt/conf/ssl-dhparams.pem;

  # This may be turned off in dev. It will force the browser to "stick" to a
  # HTTPS for a year. If you want to enable it, just uncomment.
  # add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;

  # Avoid the page to be embedded in iframes.
  add_header X-Frame-Options SAMEORIGIN;

  # Avoid the browser to have to "guess" the MIME type
  add_header X-Content-Type-Options nosniff;

  location / {
    # It disables client cache (useful for dynamic testing)
    # If your responses should be in "real time", better keep it.
    # If your app can afford cache, you may turn it off.
    expires epoch;

    # Pass requests to our upstream (defined above)
    proxy_pass http://backend;

    # Keeps the original host. Useful if our app uses the domain our host for something.
    proxy_set_header Host $host;

    # Pass the real client IP to our app. Useful for logging, blocking, etc.
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

    # This tells the backend if the original request was HTTP or HTTPS.
    proxy_set_header X-Forwarded-Proto $scheme;

    # This uses a map after the server block to decide:
    # Upgrade and Connection Headers
    proxy_http_version 1.1;
    # This header lists the protocols to the client
    proxy_set_header Upgrade $http_upgrade;
    # This is a mandatory companion header that must include the value
    # Upgrade to signal to any intermediate proxies that the Upgrade
    # header is hop-by-hop and should not be ignored or forwarded
    # to the next server as a standard header.
    proxy_set_header Connection $connection_upgrade;

    # Defines in which situations Nginx can try another upstream (failover)a.
    # When one of the things defined here happens, Nginx will send requests to
    # another server.
    proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504;

    # Do not rewrite the Location/Redirect header from our backend.
    # Doing that means the client will receive the raw location header from our backend.
    # Nginx does rewrite this by default.
    proxy_redirect off;

    # This is to improve the throughput a little bit, but if you use streaming,
    # turn that off as it will delay events.
    proxy_buffering on;

    # Max time to connect to the upstream
    proxy_connect_timeout 15s;

    # Max time without receiving data from the upstream
    proxy_read_timeout 65s;

    # Max time to send data to the upstream
    proxy_send_timeout 65s;
  }
}

# This is used by the headers Connection and Upgrade
map $http_upgrade $connection_upgrade {
    default upgrade;
    ''      '';
}
